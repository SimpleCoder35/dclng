import base64, json, logging
from collections.abc import Iterable
from concurrent.futures import ThreadPoolExecutor
from io import BytesIO
from pathlib import Path
from typing import ClassVar, Literal, Optional, Type, Union, List
import boto3
from PIL import Image
from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import (
    AcceleratorOptions, PdfPipelineOptions, PictureDescriptionBaseOptions)
from docling.document_converter import DocumentConverter, PdfFormatOption
from docling.exceptions import OperationNotAllowed
from docling.models.picture_description_base_model import PictureDescriptionBaseModel

logging.basicConfig(level=logging.INFO)
_log = logging.getLogger(__name__)

# --- Self-Contained Bedrock Plugin --- 
class PictureDescriptionBedrockApiOptions(PictureDescriptionBaseOptions):
    kind: ClassVar[Literal["bedrock_api"]] = "bedrock_api"
    model_id: str = "anthropic.claude-3-sonnet-20240229-v1:0"
    region_name: Optional[str] = "us-east-1"
    profile_name: Optional[str] = None
    max_workers: int = 3
    temperature: float = 0.5
    max_tokens: int = 300
    prompt: str = "Describe the image in 1-3 factual sentences."

class PictureDescriptionBedrockApiModel(PictureDescriptionBaseModel):
    @classmethod
    def get_options_type(cls) -> Type:
        return PictureDescriptionBedrockApiOptions

    def __init__(self, enabled: bool, enable_remote_services: bool, artifacts_path: Optional[Union[Path, str]], options: PictureDescriptionBedrockApiOptions, accelerator_options: AcceleratorOptions):
        super().__init__(enabled=enabled, enable_remote_services=enable_remote_services, artifacts_path=artifacts_path, options=options, accelerator_options=accelerator_options)
        self.options: PictureDescriptionBedrockApiOptions
        self.provenance = "amazon-bedrock"
        if self.enabled:
            if not enable_remote_services:
                raise OperationNotAllowed("Set pipeline_options.enable_remote_services=True.")
            session = boto3.Session(profile_name=self.options.profile_name) if self.options.profile_name else boto3.Session()
            self.bedrock_client = session.client(service_name="bedrock-runtime", region_name=self.options.region_name) if self.options.region_name else session.client(service_name="bedrock-runtime")

    def _call_bedrock_for_image(self, image: Image.Image) -> str:
        try:
            img_buffer = BytesIO()
            image_format = "jpeg" if image.mode == "RGB" else "png"
            image.save(img_buffer, format=image_format)
            image_base64 = base64.b64encode(img_buffer.getvalue()).decode("utf-8")

            if not self.options.model_id.startswith("anthropic.claude-3"):
                return f"Unsupported model: {self.options.model_id}"

            request_body = {
                "anthropic_version": "bedrock-2023-05-31",
                "max_tokens": self.options.max_tokens,
                "temperature": self.options.temperature,
                "messages": [{"role": "user", "content": [
                    {"type": "image", "source": {"type": "base64", "media_type": f"image/{image_format}", "data": image_base64}},
                    {"type": "text", "text": self.options.prompt}
                ]}]}

            response = self.bedrock_client.invoke_model(modelId=self.options.model_id, body=json.dumps(request_body), contentType="application/json", accept="application/json")
            response_body = json.loads(response.get("body").read())
            return "".join(c.get("text", "") for c in response_body.get("content", []) if c.get("type") == "text").strip()

        except Exception as e:
            _log.error(f"Error with Bedrock: {e}", exc_info=True)
            return f"Error processing image: {e}"

    def _annotate_images(self, images: List[Image.Image]) -> Iterable[str]:
        with ThreadPoolExecutor(max_workers=self.options.max_workers) as executor:
            return list(executor.map(self._call_bedrock_for_image, images))

# --- Main Execution --- 
def run_bedrock_captioning(pdf_path: str, output_dir: str):
    """Processes a PDF to generate image captions using Bedrock."""
    # 1. Configure pipeline
    bedrock_opts = PictureDescriptionBedrockApiOptions(
        prompt="Provide a concise, factual description of this image in one sentence."
    )
    pipeline_opts = PdfPipelineOptions(
        enable_remote_services=True,
        do_picture_description=True,
        picture_description_model=PictureDescriptionBedrockApiModel,
        picture_description_options=bedrock_opts,
        generate_picture_images=False
    )

    # 2. Convert document
    converter = DocumentConverter(format_options={InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_opts)})
    doc = converter.convert(pdf_path).document

    # 3. Save output
    output_path = Path(output_dir) / f"{Path(pdf_path).stem}-bedrock.md"
    output_path.parent.mkdir(exist_ok=True)
    doc.save_as_markdown(output_path)

    print(f"Successfully created markdown with Bedrock annotations: {output_path}")

if __name__ == "__main__":
    # IMPORTANT: Replace with the actual path to your PDF file
    PDF_FILE = r'file.pdf' 
    OUTPUT_DIRECTORY = './output'

    if not Path(PDF_FILE).exists():
        print(f"Error: PDF file not found at '{PDF_FILE}'. Please update the PDF_FILE variable.")
    else:
        run_bedrock_captioning(PDF_FILE, OUTPUT_DIRECTORY)
